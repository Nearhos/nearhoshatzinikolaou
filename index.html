<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nearhos Hatzinikolaou | Portfolio</title>
    <link rel="stylesheet" href="styles.css">
    <script defer src="script.js"></script>
</head>
<body>
    <!-- All your existing HTML content remains exactly the same -->
    <!-- ... -->

    <script type="module" src="https://unpkg.com/@google/model-viewer@latest/dist/model-viewer.min.js"></script>
    <script>
        document.addEventListener("scroll", () => {
            document.querySelector(".nav").style.background = "rgba(0, 0, 0, 0.9)";
        });

        var projects = [
            // Your project data remains the same
            // ...
        ];

        function createProjectElements() {
            // Your existing implementation
            // ...
        }

        function typeEffect(element) {
            const isProjectElement = element.classList.contains('green-link') && 
                                   element.id.startsWith('project');
            
            if (isProjectElement) {
                const projectIndex = parseInt(element.id.replace('project', '')) || 0;
                const currentProject = projects[projectIndex];
                
                if (currentProject && !element.classList.contains("typed")) {
                    let i = 0;
                    element.innerHTML = '';
                    element.href = currentProject.link;
                    
                    // Use a more reliable typing implementation
                    const textNode = document.createTextNode("");
                    element.appendChild(textNode);
                    
                    const typeNextCharacter = () => {
                        if (i < currentProject.name.length) {
                            textNode.nodeValue += currentProject.name.charAt(i);
                            i++;
                            requestAnimationFrame(typeNextCharacter);
                        } else {
                            element.classList.add("typed");
                        }
                    };
                    
                    // Start typing immediately but throttle with requestAnimationFrame
                    typeNextCharacter();
                }
                return;
            }
            
            // Original typeEffect for non-project elements with improved reliability
            let text = element.innerHTML;
            element.innerHTML = "";

            let span = document.createElement("span");
            span.classList.add("typing");
            element.appendChild(span);

            let i = 0;
            const typeCharacter = () => {
                if (i < text.length) {
                    if (text[i] === "<") {
                        let endIndex = text.indexOf(">", i);
                        if (endIndex !== -1) {
                            span.innerHTML += text.substring(i, endIndex + 1);
                            i = endIndex;
                        }
                    } else {
                        span.innerHTML += text[i];
                    }
                    i++;
                    requestAnimationFrame(typeCharacter);
                } else {
                    span.style.borderRight = "none";
                    element.classList.add("typed");
                }
            };
            
            typeCharacter();
        }

        document.addEventListener("DOMContentLoaded", () => {
            createProjectElements();
            
            // Improved IntersectionObserver with better thresholds and rootMargin
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const elements = entry.target.querySelectorAll(".type-effect:not(.typed)");
                        elements.forEach(el => {
                            // Ensure typing starts even if element scrolls out quickly
                            if (!el.classList.contains("typing-active")) {
                                el.classList.add("typing-active");
                                typeEffect(el);
                            }
                        });
                    }
                });
            }, { 
                threshold: 0.1, // Lower threshold to catch elements earlier
                rootMargin: "0px 0px 100px 0px" // Add 100px bottom margin to trigger earlier
            });

            // Observe all sections and individual important elements
            document.querySelectorAll(".section, .type-effect").forEach(element => {
                observer.observe(element);
            });

            // Fallback: Check for any untyped elements after scrolling stops
            let scrollTimeout;
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    document.querySelectorAll(".type-effect:not(.typed)").forEach(el => {
                        if (isElementInViewport(el) && !el.classList.contains("typing-active")) {
                            el.classList.add("typing-active");
                            typeEffect(el);
                        }
                    });
                }, 300);
            });

            // Helper function to check if element is in viewport
            function isElementInViewport(el) {
                const rect = el.getBoundingClientRect();
                return (
                    rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.bottom >= 0
                );
            }
        });
    </script>
</body>
</html>
